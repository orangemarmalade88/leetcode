package graph;

import java.util.HashSet;
import java.util.Set;

public class MinimizeMalwareSpread {
	/*
	 * You are given a network of n nodes represented as an n x n adjacency
	 * matrix graph, where the ith node is directly connected to the jth node if
	 * graph[i][j] == 1.
	 * 
	 * Some nodes initial are initially infected by malware. Whenever two nodes
	 * are directly connected, and at least one of those two nodes is infected
	 * by malware, both nodes will be infected by malware. This spread of
	 * malware will continue until no more nodes can be infected in this manner.
	 * 
	 * Suppose M(initial) is the final number of nodes infected with malware in
	 * the entire network after the spread of malware stops. We will remove
	 * exactly one node from initial.
	 * 
	 * Return the node that, if removed, would minimize M(initial). If multiple
	 * nodes could be removed to minimize M(initial), return such a node with
	 * the smallest index.
	 * 
	 * Note that if a node was removed from the initial list of infected nodes,
	 * it might still be infected later due to the malware spread.
	 * 
	 * 
	 */

	// O(N)
	public int minMalwareSpread(int[][] graph, int[] initial) {
		int s = graph.length;
		boolean[] visited = new boolean[s];
		Set<Integer> set = new HashSet<>();
		int smallest = Integer.MAX_VALUE;
		for (int i : initial) {
			set.add(i);
			smallest = Math.min(smallest, i);
		}
		int max_size = -1;
		int ans = s;
		for (int i = 0; i < s; i++) {
			if (!visited[i]) {
				int[] result = new int[2];
				result[0] = -1;
				dfs(graph, set, visited, i, result);
				if (result[0] >= 0 && result[1] >= max_size) {
					if (result[1] == max_size && ans > result[0])
						ans = result[0];
					if (result[1] > max_size)
						ans = result[0];
					max_size = result[1];
				}
			}
		}
		if (ans == s) {
			return smallest;
		}
		return ans;
	}

	public void dfs(int[][] graph, Set<Integer> set, boolean[] visited, int i,
			int[] result) {
		if (set.contains(i)) {
			if (result[0] == -1) {
				result[0] = i;
			} else if (result[0] >= 0) {
				result[0] = -2;
			}
		}
		visited[i] = true;
		result[1]++;
		for (int next = 0; next < visited.length; next++) {
			if (next != i && graph[i][next] == 1 && !visited[next]) {
				dfs(graph, set, visited, next, result);
			}
		}
	}

	public static void main(String[] args) {
		MinimizeMalwareSpread m = new MinimizeMalwareSpread();
		int[][] graph = new int[4][4];
		graph[3][2] = 1;
		graph[2][3] = 1;
		int[] initial = new int[2];
		initial[0] = 3;
		initial[1] = 1;
		m.minMalwareSpread(graph, initial);
	}
}
